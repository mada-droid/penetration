import os
import sys
import time
from datetime import datetime

from PyQt5.QtCore import Qt, QSize
from PyQt5.QtGui import QPalette, QColor, QFont, QCursor, QIcon, QIntValidator
from PyQt5.QtWidgets import QApplication, QMainWindow, QVBoxLayout, QHBoxLayout, QWidget, QToolButton, QTextEdit, \
    QLabel, QTableWidget, QTableWidgetItem, QHeaderView, QLineEdit

import Test_environment


class MyWindow(QMainWindow):

    def __init__(self):
        # self.is_loop = False
        self.differentFrames = []

        super().__init__()

        self.initUI()

    def initUI(self):
        # -------------------------------
        self.setWindowTitle("AVL Italy : Test Environment")
        self.setWindowIcon(QIcon('Images/Pentesting.png'))
        self.setGeometry(200, 200, 1500, 750)
        central_widget = QWidget(self)
        self.setCentralWidget(central_widget)
        self.setPaletteColors()

        # Create a horizontal layout for the main window
        main_layout = QHBoxLayout()
        main_layout.setAlignment(Qt.AlignHCenter)
        # Create a left layout for menu buttons (arranged vertically)
        self.left_layout = QVBoxLayout()
        self.left_layout.setAlignment(Qt.AlignHCenter)  # Align buttons to the top

        self.leftButtonsInit()
        self.stopButtonInit()
        self.rightLayoutInit()

        main_layout.addLayout(self.left_layout)
        main_layout.addLayout(self.right_layout)

        central_widget.setLayout(main_layout)

        self.exitButtonInit()

    def show_output(self):

        self.output_text.clear()
        self.output_text.show()

        # Show the output_text and Stop button upon clicking the buttons on the left
        self.button_text = self.sender().text()
        self.report_button.hide()
        self.feature_title.setText(self.button_text)
        self.feature_title.show()

        self.globalVariableSetup()

        match self.button_text:
            case "Bus traffic":
                self.report_button.show()
                self.BusSniffing()

            case "Sniffing unusual traffic":
                self.SniffingUnusualTraffic()

            case "Brute force of Tester ID":
                self.report_button.show()
                self.BruteForceTesterID()

            case "DoS attack":
                self.report_button.show()
                self.DoSAttack()

            case "Replay attack":
                self.ReplayAttack()

            case "UDS scanning attack":
                self.report_button.show()
                self.ScanningUDSAttack()

            case "Security access exploitation":
                self.report_button.show()
                self.SecurityAccessExploitation()

            case "Send custom CAN frames":
                self.SendCustomCanFrames()

    # % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/
    # % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/
    # TEST ENVIRONMENT FEATURES
    # % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/
    # % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/

    # % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/
    # 1) Normal bus traffic sniffing
    # % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ 
    def BusSniffing(self):
        traffic = []
        self.is_loop = True
        self.is_receiving = True

        self.showStopButton()

        for msg in bus:

            if not self.is_loop or self.button_text != "Bus traffic":
                break
            if self.is_receiving:
                self.output_text.append(str(msg))
                traffic.append(msg)

                fileTraffic = open(self.folder_path + "/Bus_traffic_report.txt", "w")
                print("\nWriting the CAN frames on the file 'Bus_traffic_report.txt'...")
                for msg in traffic:
                    fileTraffic.write(str(msg) + '\n')
                print("Write 'Bus_traffic_report.txt' done!")
                fileTraffic.close()

            app.processEvents()

        self.hideStopButton()

    # % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/
    # 2) Sniffing the frames from new IDs and save them on a file
    # % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/
    def SniffingUnusualTraffic(self):

        self.output_text.append(f"Waiting for new CAN messages to be sniffed...\n")
        self.showStopButton()

        for msg in bus:
            if not self.is_loop:
                break

            if self.is_receiving and hex(msg.arbitration_id) not in Test_environment.normalTrafficIDs:
                self.differentFrames.append(msg)
                self.output_text.append(str(msg) + "\n")

            app.processEvents()

        self.hideStopButton()

    # % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/
    # 3) Brute force all the combinations to find the Tester ID
    # % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ 
    def BruteForceTesterID(self):
        self.output_text.append(f"Trying to obtain a valid CAN ID using a Brute Force attack...\n")

        if self.testerID != 0:
            self.output_text.append("Tester ID is already known: " + str(hex(self.testerID)) + "\n")
            self.output_text.append("Tester Response ID is already known: " + str(hex(self.testerResponseID)) + "\n")

            return

        self.showStopButton()

        self.output_text.append("Brute forcing the tester and tester response IDs...\n")
        currentTesterID = 0x00000000  # It's better to start from 0x00000000 to simulate a correct Brute force attack
        currentTesterIDList = []
        while currentTesterID < 0xFFFFFFFF and self.is_loop and self.button_text == "Brute force of Tester ID":

            self.output_text.append("currentTesterID sent--> " + str(hex(currentTesterID)) + "\n")
            currentTesterIDList.append("currentTesterID sent--> " + str(hex(currentTesterID)) + "\n")

            app.processEvents()
            if not self.is_receiving:
                continue

            #Tester Prensent
            msg = Test_environment.can.Message(arbitration_id=currentTesterID,
                                               data=[0x01, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
                                               is_extended_id=True, is_rx=False)

            response = Test_environment.sendMessage(bus, msg, 0x3E, True)

            if hex(response.arbitration_id) != '0xffffffff':
                data = [f"{byte:#02x}" for byte in response.data]

                if data[1] == '0x7e' or data[1] == '0x7f':
                    break

            currentTesterID += 0x00000001
        if self.button_text == "Brute force of Tester ID":
            self.output_text.append("-" * 70 + "\nOh yes, Brute force attack terminated with success!")
            self.hideStopButton()

            self.output_text.append("-" * 70 + "\n\nBrute force attack results:")
            self.output_text.append("\nTester ID is: " + str(hex(currentTesterID)))
            self.output_text.append('Tester response ID is: ' + str(hex(response.arbitration_id)))

            bruteForceAttackReport = open(self.folder_path + "/Brute_force_attack_report.txt", "w")
            print("\nWriting the CAN frames on the file 'Brute_force_attack_report.txt'...")
            for msg in currentTesterIDList:
                bruteForceAttackReport.write(str(msg))

            bruteForceAttackReport.write("-" * 70 + "\nOh yes, Brute force attack terminated with success!\n")
            bruteForceAttackReport.write("-" * 70 + "\n\nBrute force attack results:\n")
            bruteForceAttackReport.write("\nTester ID is: " + str(hex(currentTesterID)))
            bruteForceAttackReport.write('\nTester response ID is: ' + str(hex(response.arbitration_id)))

            print("Write 'Brute_force_attack_report.txt' done!")
            bruteForceAttackReport.close()

            self.output_text.append(f'\n\nFor further analysis please open the "Brute_force_attack_report.txt" report')
        self.testerID = currentTesterID
        self.testerResponseID = response.arbitration_id
        app.processEvents()

    # % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/
    # 4) DoS attack 
    # % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/

    def DoSAttack(self):
        self.output_text.clear()
        dosAttackReport = open(self.folder_path + "/DoS_attack_report.txt", "w")
        self.output_text.append(
            f"Launching a Denial of service attack for 1 minute...\n(Please check the bus load with BusMaster)\n")
        dosAttackReport.write(
            "Launching a Denial of service attack for 1 minute...\n(Please check the bus load with BusMaster)\n")

        msg = Test_environment.can.Message(arbitration_id=self.testerID,
                                           data=[0x02, 0x10, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00],
                                           is_extended_id=True, is_rx=False)

        start = datetime.now()
        dt_string_start = start.strftime("%H:%M:%S")
        self.output_text.append(
            f"-----------------\nDoS attack start time: " + dt_string_start + "\n-----------------\n")
        dosAttackReport.write(
            "\n-----------------\nDoS attack start time: " + dt_string_start + "\n-----------------\n")

        self.showStopButton()
        t_end = time.time() + 60 #DoS attack for 1 minute
        msgCounter = 0

        while time.time() < t_end and self.is_receiving:
            app.processEvents()

            try:
                # res = bus.send_periodic(msg, 1) #FOR NO BUS OVERLOADING
                res = bus.send_periodic(msg, 0.0001)
                if not self.is_receiving:
                    self.stop_button.setIcon(QIcon('Images/pause.png'))
                    self.stop_button.setToolTip("Pause execution")
                    self.stop_button.setStyleSheet(
                        "QToolButton#red-button {background-color: rgba(255, 0, 0, 200); border: 8px solid red; border-radius: 5px; color: white;}"
                        "QToolButton#red-button:hover {background-color: rgba(255, 0, 0, 255); border: 8px solid white;}"
                    )
                    self.hideStopButton()
                    break

                if res is not None:
                    msgCounter += 1

            finally:
                #time.sleep(1)  # to use only to read better the script
                now = datetime.now()
                dt_string = now.strftime("%H:%M:%S")

                self.output_text.append(
                    f"Sending msg: " + hex(int.from_bytes(msg.data[0:7], 'big')) + " to the bus--Current time: " + dt_string + "\n")
                dosAttackReport.write(
                    "Sending msg: " + hex(int.from_bytes(msg.data[0:7], 'big')) + " to the bus...--Current time: " + dt_string + "\n")

                with open(self.folder_path + "/Bus_error_report.txt", "r") as file:
                    contents = file.read()
                    self.output_text.append(contents)
                    dosAttackReport.write(contents + "\n")
                continue

        # self.hideStopButton()
        end = datetime.now()
        dt_string_end = end.strftime("%H:%M:%S")

        self.output_text.append(f"\n-----------------\nDoS attack end time: " + dt_string_end)
        self.output_text.append(f"\nTotal number of CAN messages sent: " + str(msgCounter))
        dosAttackReport.write("\n-----------------\nDoS attack end time: " + dt_string_end)
        dosAttackReport.write("\nTotal number of CAN messages sent: " + str(msgCounter))
        dosAttackReport.close()

        self.stop_button.setIcon(QIcon('Images/pause.png'))
        self.stop_button.setToolTip("Pause execution")
        self.stop_button.setStyleSheet(
            "QToolButton#red-button {background-color: rgba(255, 0, 0, 200); border: 8px solid red; border-radius: 5px; color: white;}"
            "QToolButton#red-button:hover {background-color: rgba(255, 0, 0, 255); border: 8px solid white;}"
        )
        self.hideStopButton()
    # % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/
    # 5) Replay attack based on a new message obtained from the scanning
    # % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ 
    def ReplayAttack(self):

        self.showStopButton()
        self.inputText.setPlaceholderText("Choose an index from the list and press enter: ")

        self.inputText.setValidator(QIntValidator())

        index = 0
        for msg in self.differentFrames:
            self.output_text.append(str(index) + ') ' + str(msg) + "\n")
            index += 1

        self.inputText.show()

        while self.is_loop:
            app.processEvents()

            if not self.is_receiving:
                if self.inputText.text() == "":
                    continue

                payload = [f"{byte:#02x}" for byte in self.differentFrames[int(self.inputText.text())].data]

                res = Test_environment.sendMessage(bus, self.differentFrames[int(self.inputText.text())],
                                                   int(payload[1], 16), True)

                self.output_text.append("\n############## Replay Attack ##############"
                                        "\n\nIndex selected: " + str(
                    self.inputText.text()) + "\nCAN frame sent: " + str(
                    self.differentFrames[int(self.inputText.text())]))
                self.output_text.append("\nReplay attack response: " + str(res))

                self.is_receiving = True
                self.inputText.clear()

    # % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/
    # 6) Scan for all the UDS services and report the result
    # % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/
    def ScanningUDSAttack(self):

        # self.right_layout.addWidget(self.UDS_scanning_table)

        self.output_text.append(f"Scanning all the UDS services...")
        app.processEvents()
        self.showStopButton()

        # Show the UDS scanning table and scroll it to the top
        self.UDS_scanning_table.show()
        self.UDS_scanning_table.setEnabled(True)
        self.UDS_scanning_table.scrollToTop()

        scanningResult = Test_environment.ScanningUDSAttack(bus, self.folder_path)

        # Populate the UDS scanning table with the scanning result
        self.populate_UDS_scanning_table(scanningResult)
        self.UDS_scanning_table.setFixedHeight(450)

        self.output_text.setText(
            f'Scanning completed!\nPlease check the "Response" column for further informations or open the "UDS_scanning_attack_report.txt" report\n')

        self.hideStopButton()

    # % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/
    # 7) Send security access and gaining permissions after sniffing and analysis
    # % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/
    def SecurityAccessExploitation(self):
        app.processEvents()
        securityAccessExploitationReport = open(self.folder_path + "/Security_access_exploitation_report.txt", "w")
        seedRequest, seedRequestResponse, sendKey, keyValidationResponse, error = Test_environment.SecurityAccessExploitation(
            bus)

        self.output_text.append("Changing diagnostic session to enable the security access...\n")
        self.output_text.append("-----------------------------------------")
        self.output_text.append("Send seed request:\n" + str(seedRequest))

        # If they are the same it is configured that there's a seed request error
        if seedRequest == sendKey:
            self.output_text.append("\n--X--X--X--X-- Seed request error --X--X--X--X--\n")
            self.output_text.append("\t" + error)
            self.output_text.append("\nSecurity access status: Not authenticated!")
            self.output_text.append("\n--X--X--X--X-- Seed request error --X--X--X--X--\n")
            securityAccessExploitationReport.write(str(self.output_text.toPlainText()))
            return
        self.output_text.append("-----------------------------------------")
        self.output_text.append("\nSeed request response:\n" + str(seedRequestResponse))
        self.output_text.append("\n-----------------------------------------")
        self.output_text.append("\nCalculating the key from the seed received...")
        self.output_text.append("\n-----------------------------------------")
        self.output_text.append("Send the key:\n" + str(sendKey))

        if error != "":
            self.output_text.append("\n--X--X--X--X-- Key validation error --X--X--X--X--\n")
            self.output_text.append("\t" + error)
            self.output_text.append("\nSecurity access status: Not authenticated!")
            self.output_text.append("\n--X--X--X--X-- Key validation error --X--X--X--X--\n")
            securityAccessExploitationReport.write(str(self.output_text.toPlainText()))
            return

        self.output_text.append("-----------------------------------------")
        self.output_text.append("\nKey validation response:\n" + str(keyValidationResponse))
        self.output_text.append("\n-----------------------------------------")
        self.output_text.append("\nSecurity access status: Successfully authenticated in the system!")

        securityAccessExploitationReport.write(str(self.output_text.toPlainText()))
        securityAccessExploitationReport.close()

    # % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/
    # 8) Send custom CAN frames
    # % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/
    def SendCustomCanFrames(self):
        self.inputText.setPlaceholderText(
            "Create a CAN frame as: [length] [service] [sub-service] [payload] (don't use square brackets)")
        self.inputText.show()
        self.inputText.setValidator(None)

        self.is_loop = True
        self.is_receiving = True

        while self.is_loop:
            app.processEvents()

            if not self.is_receiving:

                frame = self.inputText.text().split(" ")

                if frame[0] == '':
                    return

                payload = [(int(num, 16)) for num in frame]

                while len(payload) < 8:
                    payload.append(0x0)

                msg = Test_environment.can.Message(arbitration_id=0x17FC007B, data=payload,
                                                   is_extended_id=True, is_rx=False)

                res = Test_environment.sendMessage(bus, msg, int(frame[1], 16))

                self.output_text.append("\nCAN frame sent: " + str(msg))
                self.output_text.append("\nResponse: " + str(res) + "\n\n##########################")

                self.is_receiving = True
                self.inputText.clear()

    # % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/
    # % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/
    # AUX FUNCTIONS
    # % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/
    # % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/

    def globalVariableSetup(self):
        self.is_loop = False
        self.is_receiving = False
        #self.testerID = 0x17FC007B #real testerID address
        self.testerID = 0x00000000  # to start from 0x00000000 a Brute Force attack
        #self.testerResponseID = 0x17FE007B  #real testerResponseID address
        self.testerResponseID = 0x00000000  # to start from 0x00000000 a Brute Force attack

        self.hideStopButton()
        self.inputText.hide()
        self.UDS_scanning_table.hide()
        self.UDS_scanning_table.setEnabled(False)

        now = datetime.now()
        # dd/mm/YY
        dt_string = now.strftime("%d-%m-%Y")
        self.folder_path = "AVL_Test_Environment_Report_" + str(dt_string)
        if not os.path.exists(self.folder_path):
            os.makedirs(str(self.folder_path))

    # Show and hide stop button
    def showStopButton(self):
        self.is_loop = True
        self.is_receiving = True
        self.stop_button.show()
        self.stop_button.setEnabled(True)

    def hideStopButton(self):
        self.stop_button.hide()
        self.stop_button.setEnabled(False)

    def open_report_file(self):
        now = datetime.now()
        dt_string = now.strftime("%d-%m-%Y")
        path_folder = "AVL_Test_Environment_Report_" + str(dt_string)

        match self.button_text:
            case "Bus traffic":
                print("---->BusTraffic")
                os.system('notepad ' + path_folder + "/Bus_traffic_report.txt")

            case "UDS scanning attack":
                # self.report_button.show()
                print("---->UDS scanning attack")
                os.system('notepad ' + path_folder + "/UDS_scanning_attack_report.txt")

            case "Brute force of Tester ID":
                # self.report_button.show()
                print("---->Brute force of Tester ID")
                os.system('notepad ' + path_folder + "/Brute_force_attack_report.txt")

            case "DoS attack":
                # self.report_button.show()
                print("----DoS attack")
                os.system('notepad ' + path_folder + "/DoS_attack_report.txt")

            case "Security access exploitation":
                print("----Security access exploitation")
                os.system('notepad ' + path_folder + "/Security_access_exploitation_report.txt")

            case _:
                print("Open report button hiding...")
                self.report_button.hide()


    def stop_logic(self):
        self.is_receiving = not self.is_receiving
        if not self.is_receiving:
            self.stop_button.setIcon(QIcon('Images/play.png'))
            self.stop_button.setToolTip("Start/Resume execution")
            self.stop_button.setStyleSheet(
                "QToolButton#red-button {background-color: blue; border: 8px solid; border-color: rgba(52, 158, 235, 200); border-radius: 5px; color: white;}"
                "QToolButton#red-button:hover {background-color: rgba(52, 158, 235, 255); border: 8px solid white;}"
            )
        else:
            self.stop_button.setIcon(QIcon('Images/pause.png'))
            self.stop_button.setToolTip("Pause execution")
            self.stop_button.setStyleSheet(
                "QToolButton#red-button {background-color: rgba(255, 0, 0, 200); border: 8px solid red; border-radius: 5px; color: white;}"
                "QToolButton#red-button:hover {background-color: rgba(255, 0, 0, 255); border: 8px solid white;}"
            )
            self.is_receiving = True

    def exit_program(self):
        bus.shutdown()
        sys.exit()

    def onEnterInput(self):
        self.is_receiving = False

    def populate_UDS_scanning_table(self, file_content):
        # Split the file content into rows and populate the UDS_scanning_table
        rows = file_content.strip().split('\n')

        self.UDS_scanning_table.setRowCount(len(rows))

        header = self.UDS_scanning_table.horizontalHeader()
        for i, row in enumerate(rows):

            app.processEvents()
            columns = row.split()
            self.UDS_scanning_table.setColumnCount(len(columns))  # Adjust column count based on data

            for j, column in enumerate(columns):
                item = QTableWidgetItem(column)
                item.setForeground(Qt.white)  # Set text color to white
                self.UDS_scanning_table.setItem(i, j, item)

        # Set the horizontal header's stretch mode to make columns fill the available space
        header.setSectionResizeMode(QHeaderView.Stretch)
        header.setStyleSheet("color: black;")

    # % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/
    # % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/
    # GUI SETUP
    # % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/
    # % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/ % \_/

    def setPaletteColors(self):
        palette = QPalette()
        palette.setColor(QPalette.Window, QColor(40, 40, 60))
        palette.setColor(QPalette.WindowText, Qt.white)
        palette.setColor(QPalette.Button, QColor(60, 60, 80))
        palette.setColor(QPalette.ButtonText, Qt.white)
        palette.setColor(QPalette.Base, QColor(50, 50, 70))
        palette.setColor(QPalette.AlternateBase, QColor(60, 60, 80))
        palette.setColor(QPalette.Highlight, QColor(0, 122, 204))
        palette.setColor(QPalette.HighlightedText, Qt.white)
        self.setPalette(palette)

    def leftButtonsInit(self):

        # left_button_layout = QVBoxLayout()

        self.buttons = [
            {"text": "Bus traffic", "icon_path": "Images/security.png"},
            {"text": "Sniffing unusual traffic", "icon_path": "Images/mitm_8.png"},
            {"text": "Brute force of Tester ID", "icon_path": "Images/tester_id.png"},
            {"text": "DoS attack", "icon_path": "Images/dos.png"},
            {"text": "Replay attack", "icon_path": "Images/reload.png"},
            {"text": "UDS scanning attack", "icon_path": "Images/fuzz_2.png"},
            {"text": "Security access exploitation", "icon_path": "Images/securityaccess_2.png"},
            {"text": "Send custom CAN frames", "icon_path": "Images/custom_can.png"}
        ]

        self.button_font = QFont("Arial", 15, QFont.Bold)

        for button_info in self.buttons:
            button = QToolButton()
            button.setToolButtonStyle(Qt.ToolButtonTextBesideIcon)

            button.setIcon(QIcon(button_info["icon_path"]))  # Set the button's icon
            button.setIconSize(QSize(60, 60))  # Adjust the icon size as needed
            button.setText(button_info["text"])
            button.setFont(QFont("Arial", 12, QFont.Bold))
            button.setCursor(QCursor(Qt.PointingHandCursor))  # Change cursor on hover
            button.setStyleSheet(
                "QToolButton {background-color: transparent; border: none; color: white; border-radius: 5px; text-align: center;}"  # Rounded corners
                "QToolButton:hover {background-color: rgba(100, 100, 200, 100); border-radius: 5px;}"
                # Rounded hover effect
            )

            # Set a tooltip for each button
            if button_info["text"] == "Bus traffic":
                button.setToolTip("Listen and shows all the CAN frames passing through the bus")
            elif button_info["text"] == "Sniffing unusual traffic":
                button.setToolTip("Catch all the frames from IDs different than the usuals")
            elif button_info["text"] == "Brute force of Tester ID":
                button.setToolTip(
                    "Brute force all the possibile combinations to get the Tester and Tester Response IDs")
            elif button_info["text"] == "DoS attack":
                button.setToolTip("DoS attack - Send thousands of diagnostic frames to overload the bus")
            elif button_info["text"] == "Replay attack":
                button.setToolTip("Replay attack - Send a diagnostic CAN frame again from the ones sent by the tester")
            elif button_info["text"] == "UDS scanning attack":
                button.setToolTip("Scan for all the UDS services and report the result")
            elif button_info["text"] == "Security access exploitation":
                button.setToolTip("After previous analysis, exploit the system using the security access")
            elif button_info["text"] == "Send custom CAN frames":
                button.setToolTip("Send a CAN frame built by the attacker")

            button.clicked.connect(self.show_output)

            # Add spacer items to push the buttons to the top
            for _ in range(len(self.buttons)):
                self.left_layout.addStretch()

            # left_button_layout.setAlignment(Qt.AlignCenter)
            # left_button_layout.addWidget(button)
            #
            # # Add the exit layout directly to the left layout
            # self.left_layout.addLayout(left_button_layout)
            self.left_layout.addWidget(button)

    def rightLayoutInit(self):
        # Create a right layout for the output with an icon in the center
        self.right_layout = QVBoxLayout()
        icon_label = QLabel()
        icon_label.setAlignment(Qt.AlignCenter)
        icon_label.setPixmap(QIcon('Images/avl.png').pixmap(100, 100))  # Adjust the size as needed
        icon_label.setStyleSheet("background-color: rgba(50, 50, 70, 100);")  # Increased transparency
        self.right_layout.addWidget(icon_label)

        self.report_button = QToolButton()
        self.report_button.setToolButtonStyle(Qt.ToolButtonTextUnderIcon)
        self.report_button.setIcon(QIcon("Images/reportButton.png"))  # Set the button's icon
        self.report_button.setIconSize(QSize(40, 40))  # Adjust the icon size as needed
        self.report_button.setText("Open report")
        self.report_button.setFont(QFont("Arial", 12, QFont.Bold))
        self.report_button.setCursor(QCursor(Qt.PointingHandCursor))  # Change cursor on hover
        self.report_button.setStyleSheet(
            "QToolButton {background-color: transparent; border: none; color: white; border-radius: 5px; text-align: center;}"  # Rounded corners
            "QToolButton:hover {background-color: rgba(100, 100, 200, 100); border-radius: 5px;}"
            # Rounded hover effect
        )
        self.report_button.hide()
        self.report_button.clicked.connect(self.open_report_file)

        # Add feature name at the top
        self.feature_title = QTextEdit()
        self.feature_title.setReadOnly(True)
        self.feature_title.setStyleSheet("background-color: rgba(50, 50, 70, 100); border: none; color: red;")
        self.feature_title.setFixedHeight(50)
        self.feature_title.setFont(QFont("Arial", 20, QFont.DemiBold))
        self.feature_title.adjustSize()
        self.feature_title.setAlignment(Qt.AlignCenter)
        self.feature_title.hide()
        self.right_layout.addWidget(self.feature_title)
        # self.right_layout.addWidget(report_button)

        # Add the UDS scanning table
        self.UDS_scanning_table = QTableWidget()
        self.UDS_scanning_table.setColumnCount(4)

        self.UDS_scanning_table.setHorizontalHeaderLabels(["Service", "Sub-Service", "Response", "Payload"])
        self.UDS_scanning_table.hide()  # Initially hide the table
        self.UDS_scanning_table.setRowHeight(0, 10)

        # Create a new container widget for the text
        output_container = QWidget()
        output_layout = QVBoxLayout(output_container)
        output_container.setStyleSheet("background-color: rgba(50, 50, 70, 200); border: none; color: white;")
        #output_container.setStyleSheet("background-image: url('Images/avl.png'); background-attachment: fixed; color: white; ")

        # Create the output_text widget
        self.output_text = QTextEdit()
        self.output_text.setReadOnly(True)
        self.output_text.setFont(QFont("Arial", 20,QFont.DemiBold))
        self.output_text.setAlignment(Qt.AlignLeft)  # Align the text on the left
        self.output_text.setText("__________________AVL Italy: Test Environment_________________"+"\n\n\n\n-------------->Your ECU is correctly connected to the system<--------------\n\n\n\nPlease choose your preferred test case and test the security of your system!")
        self.output_text.show()

        # Set vertical alignment to AlignTop to ensure the table appears right below the text
        output_layout.setAlignment(Qt.AlignLeft)

        # Add the input text widget
        self.inputText = QLineEdit()
        self.inputText.setMaxLength(20)
        self.inputText.setAlignment(Qt.AlignLeft)
        self.inputText.setFont(QFont("Arial", 20))
        self.inputText.setPlaceholderText("Choose an index from the list and press enter: ")
        self.inputText.returnPressed.connect(self.onEnterInput)
        self.inputText.hide()

        output_layout.addWidget(self.UDS_scanning_table)
        output_layout.addWidget(self.output_text)
        output_layout.addWidget(self.inputText)

        # Add the stop button
        output_layout.addWidget(self.stop_button, alignment=Qt.AlignCenter)

        # Add the output container to the main layout
        self.right_layout.addWidget(output_container)
        self.right_layout.addWidget(self.stop_button, alignment=Qt.AlignCenter)
        self.right_layout.addWidget(self.report_button, alignment=Qt.AlignRight)

    def stopButtonInit(self):
        # Use the same font for buttons
        self.stop_button = QToolButton()
        self.stop_button.setIcon(QIcon('Images/pause.png'))  # Add a stop icon, you can customize it
        self.stop_button.setIconSize(QSize(32, 32))  # Adjust the icon size as needed
        self.stop_button.setObjectName("red-button")
        self.stop_button.setFont(self.button_font)
        self.stop_button.setCursor(QCursor(Qt.PointingHandCursor))  # Change cursor on hover
        self.stop_button.setStyleSheet(
            "QToolButton#red-button {background-color: rgba(255, 0, 0, 200); border: 8px solid red; border-radius: 5px; color: white;}"
            "QToolButton#red-button:hover {background-color: rgba(255, 0, 0, 255); border: 8px solid white;}"
        )
        self.stop_button.clicked.connect(self.stop_logic)
        self.stop_button.hide()  # Initially hide the Stop button

    def exitButtonInit(self):
        # Create a new layout for the exit button
        exit_layout = QVBoxLayout()
        #
        # # Add spacer items to push the buttons to the top
        # for _ in range(len(self.buttons)):
        #     exit_layout.addStretch()

        exit_button = QToolButton()
        exit_button.setIcon(QIcon('Images/exit.png'))  # Set the exit button's icon (adjust the path)
        exit_button.setToolButtonStyle(Qt.ToolButtonTextBesideIcon)
        exit_button.setIconSize(QSize(50, 50))  # Adjust the icon size as needed
        exit_button.setText("  Exit the program")
        exit_button.setFont(QFont("Arial", 12, QFont.Bold))  # Adjust the font size
        exit_button.setCursor(QCursor(Qt.PointingHandCursor))
        exit_button.setStyleSheet(
            "QToolButton {background-color: rgb(0, 0, 0); border: none; color: green; border-radius: 5px; text-align: center;}"
            "QToolButton:hover {background-color: rgba(100, 100, 200, 100); border-radius: 2px;}"
        )
        exit_button.clicked.connect(self.exit_program)

        exit_button.setToolTip("Exit the program")
        exit_layout.setAlignment(Qt.AlignLeft)
        exit_layout.setContentsMargins(30, 30, 0, 10)
        exit_layout.addWidget(exit_button)

        # Add the exit layout directly to the left layout
        self.left_layout.addLayout(exit_layout)

    def UDSTableInit(self):
        self.UDS_scanning_table = QTableWidget()
        self.UDS_scanning_table.setColumnCount(4)
        self.UDS_scanning_table.setHorizontalHeaderLabels(["Service", "Sub-Service", "Response", "Payload"])
        self.UDS_scanning_table.hide()  # Initially hide the table
        self.UDS_scanning_table.setRowHeight(0, 10)

    def inputTextInit(self):
        self.inputText = QLineEdit()
        self.inputText.setMaxLength(20)
        self.inputText.setAlignment(Qt.AlignLeft)
        self.inputText.setFont(QFont("Arial", 20))
        self.inputText.returnPressed.connect(self.onEnterInput)
        self.inputText.hide()


if __name__ == '__main__':
    app = QApplication(sys.argv)
    with Test_environment.SetupBus() as bus:
        window = MyWindow()
        window.show()
        sys.exit(app.exec_())
